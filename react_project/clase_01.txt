
/***** Estructura de directorios *****/

1. Directorio Public: La carpeta Public posee todos aquellos elementos publicos que son, basicamente, elementos de media, como 
   imagenes, por ejemplo, en formato svg, el cual es un formato liviano que aparenta ser una imagen en su visual, pero por detras 
   es codigo. Este formato nos permite la creacion de diferentes etiquetas que no existen en HTML. Es un sistema de generador de 
   vectores, a traves de los cuales se van creando imagenes. Al codigo, se puede cambiar el tamaño de la imagen, el color de fondo, 
   los bordes, etc. Las ventajas de colocar imagenes en este directorio es que no es necesario, a la hora de instanciar un elemento 
   de tipo img, colocar toda la ruta de la ubcacion de la imagen, ya que se la detecta colocando unicamente el nombre en la fuente 
   (src).

2. Archivo .gitignore: Es un archivo que permite que todo lo que se coloque en el no se suba a git. Esto es asi por diferentes 
   motivos, por un lado, porque quizas no son necesarios para que funcione la aplicacion, y por otro lado hay directorios o archivos
   que son muy pesados, como el directorio node_modules, por ejemplo.

3. Hoja de eslint.config.mjs: Se instala durante el proceso de creacion del proyecto. Esta es una dependencia que muestra por 
   terminal advertencias o warnaings al ejecutar el proyecto durante el desarrollo del mismo.

4. jsconfig.json: Esta es una configuracion propia del entorno, que normalmente no se toca. Podemos importar modulos y extraer sus 
   datos, pero al momento de hacerlo usamos un "@", el cual es una abrebiacion del directorio "src", y esta es una configuracion
   basica de convencion, y esto es lo que esta configurado en este archivo.

5. next.config.mjs: Esto es algo propio de Next.Js. Tiene configurado en True el modo estricto, el cual mantiene el JS de la aplicacion
   estricto con respecto a buenas practicas. 

6. package.json: Es una hoja de configuraciones que se suele tocar mucho.
    - name: Nos indica cual es el nombre del proyecto.
    - version: Version actual del proyecto (al crearlo indica la primera).
    - private: Si esta en True indica que es privado. 
    - scripts: Todo lo que esta adentro son comandos de la terminal, que en realidad son variables que contienen un comando mas largo.
      Entonces, en lugar de ejecutar un codigo extenso ejecutamos, por ejemplo, npm run dev, y asi sucesivamente con el resto.
        - dev: Permite arrancar el programa en el contexto de desarrollo (Incluye un icono de Next).
        - start: Permite arrancar el programa en el contexto de como lo veria el cliente.
        - build: Este se ejecuta cuando se quiere crear la carpeta de produccion, aquella que se lae va a dar al hosting. Al compilar 
          crea una carpeta la cual se le provee a un servicio de hosting como hostinger o donweb.
    - dependencies: Es un objeto en el cual se van a ir alojando, todas las dependencias que vamos instalando con la version correspondiente.
      Estas son dependencias comunes que el software necesita para funcionar. Por ejemplo:
      - Tailwind: Framework de CSS.
      - Axios: Libreria para hacer peticiones.
      - Fornik: Libreria para agregar formularios prefabricados.
      - Express: Framework de Node para rutas de backend.
    - devDependencies: Son dependencias de desarrollo, que en si el software no requieren para funcionar, sino que sirven para ayudarnos
      a desarrollar. Por ejemplo:
      - Nodemon: Dependencia que se usa en el backend para evitar tener que parar el servicio y volverlo a levantar cada vez que hacemos un
        cambio en el codigo.
      - Typescript: Es un superset de JS que nos da un sistema de tipado, por ejemplo, reasiganacion de tipos de variables. No es un codigo
        que se ejecute, sino que esta ahi para controlarnos a nosotros para que no vayamos en contra de lo que establecimos originalmente.
        Permite desarrollar de manera mas ordendada y robusta. En tiempo de compilacion se ven las configuraciones, pero no se ven en tiempo
        de ejecucion, ya que es casi como un comentario para JS.

7. Readme: Es un tipo de documento que se utiliza mucho para hacer documentacion de proyectos. Podemos encontrar:
    - Codigo HTML para las imagenes.
    - Los # indican titulos, y es mas chico el titulo cuantos mas numerales tiene.
    - Con ```se hace un codigo de bloque que es posible copiarlo y se le puede indicar de que tipo es, por e jemplo, ```javascript, para que
      elija los colores y el formato, como bash, python, etc.
   El archivo posee los comandos tipicos que se usan en react por defecto, y un poco de documentacion sobre el proyecto base.

8. Directorio src: Es el codigo fuente.
    - Directorio style: Tenemos dos hojas de estilos:
        - globals: Es la que antes se llamaba style.css.
        - Home.module: Hojas modulares que en lugar de importarlas por medio de una etiqueta link en el html, se la va a importar como 
          modulo de programacion.
    - Directorio pages: Dentro de este directorio tenemos lo siguiente:
        - Archivos JS: No se utiliza HTML, se construye HTML y con JS se lo compila a traves del DOM.
            - _document: Es una configuracion propia de de Next donde esta la estructura del documento HTML, hecho todo con JS.
            - _app: Esta la configuracion general para todas las paginas, que permite que a cada una le lleguen las mismas cosas de la
              configuracion de Next.
            - index: Es una representacion de la hoja index.html. 

/**************************************************************************************************************************************/

/***** Diferenciacion entre JSX y JS *****/

- Se trabajo en archivo index.js


import React from "react";

let texto = "Esto es un texto";
let objeto = {
  nombre: "santi"
}
const lista = [1,2,3,4,5];

const variable_estilos ={
  color: "red",
  backgroundColor: "green"
}

let toggle = true;

export default function Home() {
  return (
    /*
      Lo que se coloca aca adentro, entra en el modulo de React y ejecuta React.createElement("p"), y si se añade contenido
      se colocan mas argumentos, ("p", {}, "hola"). En el espacio de llaves se listan los atributos como id, className, etc.
      Las expresiones JSX deben tener un elemento primario, esto significa que, dentro del elemento retorno (return), no 
      es posible retornar dos valores a la vez. Es necesario colocar una estructura que permita retornar varios elementos a
      la vez, como por ejemplo un div general que contenga los dos p. Ahora tendriamos algo asi como React.createElement("div", null,p p).
      Entonces los createElement de ambos p son el argumento del createElement padre del div, y asi el retorno retorna una
      sola funcion.
      Entonces, siempre tiene que haber un contenedor principal o general para poder retornar varios elmentos a la vez.
      Generalmente se suele usar la siguiente estructura: <> </>. Esta nos permite coleccionar todas las iteraciones que se 
      hacen al DOM, y despues insertar un paquete entero de forma directa. Entonces, esto es un fragmento. Originalmente,
      el fragmento en react era:
      import {Fragment} from 'React'

      return(
        <Fragment>

        </Fragment>
      );

      Pero cambio, y se reemplazo por <> el cual es basicamente un createFragment:

      <>
        <p>Hola</p>
        <p>Hola</p>
      </>
    */


    /***** Diferencias entre JSX y HTML: *****/

    /*
      Cuando creamos una etiqueta self-closign, como por ejemplo una img, cuando se elimina la barra /, sale un erro indicando
      que dicha barra es necesaria. Como esto esta basado en XML, todos los self-closing llevan la barra /, pero en HTML no
      obliga a tenerla, funciona igual ya sea que este o no.
      Otra diferencia esta relacionada con algunos atributos. Cuando creamos un elemento p, la propiedad para poner un nombre en 
      DOM de JS se llama className, por otro lado la palabra class es una palabra reservada en JS para las clases, a diferencia
      de HTML en donde para poner un nombre al elemento se utiliza class. 
      Por otro lado en el caso de los labels, estos tienen un atributo que es el for, donde se coloca el ID del input con el que 
      queremos conectar, pero no se puede usar for, como si se puede en HTML, porque es una palabra reservada, por lo que se lo 
      reemplaza por htmlFor.

      <>
        <img src="asasa" alt="asas" />

        <p className="Pepe"></p>

        <label>Nombre</label>
      </>
    */

    /***** Ventajas de JSX *****/

    /*
      Si creamos una variable que posea un texto y queremos insertarlo, por ejemplo, en una etiqueta h1, en JS puro lo que se 
      hacia era conectarnos con la etiqueta y despues entrar a su textContent y colocarle la variable.
      const $h1 = document.querySelector('h1');
      $h1.textContent = texto
      En JSX se coloca directamente dentro de la etiqueta, pero usando llaves ya que la construccion del componente seria:
      React.createElement("h1", {}, `${texto}`)
      Lo mismo seria con un objeto.
      <>
        <h1>{texto}</h1>
        <h1>{objeto.nombre}</h1>
      </>

      Ahora, si queremos mapear el contenido de un array, en JS crudo seria:
      const $ul = document.querySelector('ul');
      const $fragment = document.createDocumentFragment();
      lista.forEach(elemento => {
        const $li = document.querySelector('li'); 
        $li.textContent = elemento;
        $fragment.appendChild($li);
      });
      $ul.appendChild($fragment);
      En react es mas facil, ya que se evita la reinsercion en el fragmento, entonces simplemente se mapea la lista, y
      por cada elemento se crea un item de lista con el contenido adentro. Pero cuando se generan elementos en un 
      mapeo, varios pueden tener el mismo valor, pero hay que identificarlos como elementos distintos, entonces hay un
      warning que nos pide que usemos algun identificador para cada elemento. Si tuvieramos objetos podemos usar el
      parametro ID, pero como este no es el caso, usamos un argumento de los mapeos que se llama index, que similar al
      de los bucles for, arranca desde 0, y le coloca un indice a cada elemento que se genera.
      index = i

      <>
        <ul>
          {
            lista.map((elemento, i) => <li key={i}>{elemento}</li>)
          }
        </ul>
            
      </>
    */

    /***** Diferentes formas de poner CSS *****/
    
    /*
      1. Atributo style: A diferencia de JS puro, el atributo style se puede usar ya que colocamos logica entre llaves,
         y dentro otras llaves para colocar el objeto CSS en donde las propiedades van a estar en formato camel-case.
         Podemos colocar directamente el estilo, o usar una variable para referenciarlo. Queda mas limpio, no es redundante
         y ademas es posible trasladarlo a otra hoja:
      import {variable_estilos} from "@/components/estilos"

      <>
        <p style={estilos}>Hola</p>    
      </>


      2. La etiqueta style se puede colocar dentro del fragmento, se le coloca un atributo llamado JSX, se abren llaves
         porque se va a colocar codigo JS, se abren comillas inclinadas por ser tipo de escritura CSS, y se escriben las 
         propiedades. Lo bueno es que queda empaquetado en la misma hoja en la que se trabaja, y lo malo es que no se
         puede exportar a otras hojas. Pero tambien es posible colocar variables y construir logica dentro del CSS.

      <>
        <p>lorem ipsum dolor sir amet.</p>

        <style jsx>{`
          p{
            color: ${toggle ? "red" : "yellow"};
            background-color: green;
          }
        `}</style>
      </>


      3. La ultima forma de usar CSS es utilizando modulos. Las hojas de modulos se las usa cuando se busca aplicar
         a una pagina en particular, pero podemos tener una hoja de CSS para cada pagina.
         En estos archivos de CSS si o si se debe trabajar con clases, porque son la unica cosa que entienden los
         modulos. Al importar el modulo, se le puede poner un nombre cualquiera independientemente del nombre del 
         archivo CSS.
      import estilos from "@/styles/Home.module.css"

      <>
        <p className={estilos.parrafo}>lorem ipsum dolor sir amet.</p>
      </>
    */
    <>

    </>
  );
}





